{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/the-three-rs-rust-repl-runner/","result":{"data":{"site":{"siteMetadata":{"title":"ozbe","social":[{"name":"twitter","url":"https://twitter.com/ozbe"},{"name":"github","url":"https://github.com/ozbe"},{"name":"linkedin","url":"https://www.linkedin.com/in/josh-aaseby"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"cefc5047-87a1-5b41-811a-a327c6aad5b0","excerpt":"REPLs and runners can be a quick and easy way to iterate and execute code. Let's try different Rust REPLs & runners to see the differencesâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The Three \\\"R\\\"s: Rust, REPL, Runner\",\n  \"date\": \"2021-01-21T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"REPLs and runners can be a quick and easy way to iterate and execute code. Let\\u2019s try different Rust REPLs & runners to see the differences between each tool.\"), mdx(\"h2\", {\n    \"id\": \"intro\"\n  }, \"Intro\"), mdx(\"p\", null, \"tl;dr \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#cargo-project\"\n  }), \"Jump to the code\")), mdx(\"p\", null, \"When evaluating a new dependency I often find myself going through the same steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Do I have a pre-existing applicable project in source control?\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Yes, create a branch\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"No, create a new Cargo package\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add the dependency to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Cargo.toml\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Change some relevant code to try something out about the library\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Build\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Run\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Do I have everything I need to know to make a decision about the library\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Yes, go do what I need to do\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"No, go back to Step 3\")))), mdx(\"p\", null, \"These steps can grow tedious, especially when needing to create a new cargo package. The iterations can be shortened by more work up front looking at documentation, source, and examples. But sometimes you just want to experiment in a quick and efficient way. That is when REPLs and runners can prove to be helpful.\"), mdx(\"p\", null, \"For the uninitiated, a REPL (Read, Evaluate, Print, Loop) is typically an interactive shell that takes user input, evaluates said input, and returns the result.  Assuming I can access the required dependencies, I should be able to take the contents of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fn main()\"), \" above and enter each expressions in line-by-line into a REPL.\"), mdx(\"p\", null, \"There isn\\u2019t an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/rust-lang/rfcs/issues/655\"\n  }), \"official REPL\"), \", but there is at least one active community REPL:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/google/evcxr/blob/master/evcxr_repl/\"\n  }), \"Evcxr REPL\"))), mdx(\"p\", null, \"A Rust runner allows you to run (well, compile, link, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" run) Rust code without the overhead (and benefits) of creating a Cargo package. \"), mdx(\"p\", null, \"Similar to the REPL, there isn\\u2019t an official Rust runner, besides Cargo, but there are a few community options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/stevedonovan/runner\"\n  }), \"runner\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/reitermarkus/cargo-eval\"\n  }), \"cargo-eval\"))), mdx(\"p\", null, \"Now that we have a better idea of the landscape, let\\u2019s implement the same Rust example with these tools. \"), mdx(\"p\", null, \"Our example will use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"serde_json\"), \" to print a serialized and deserialized \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Point\"), \" struct.\"), mdx(\"h2\", {\n    \"id\": \"cargo-package\"\n  }, \"Cargo Package\"), mdx(\"p\", null, \"To start, we will create a Cargo package as a baseline. \"), mdx(\"p\", null, \"Create a new cargo package and move into the package directory:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo new cargo-serde-example\\n$ cd cargo-serde-example\\n\")), mdx(\"p\", null, \"Next, lets add the Serde dependencies we\\u2019ll need to the bottom of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[dependencies]\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"serde = { version = \\\"1.0\\\", features = [\\\"derive\\\"] }\\nserde_json = \\\"1.0\\\"\\n\")), mdx(\"p\", null, \"With the proper dependencies, change \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./src/main.rs\"), \" to match the code below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"use serde::{Serialize, Deserialize};\\n\\n#[derive(Serialize, Deserialize, Debug)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nfn main() {\\n    let point = Point { x: 1, y: 2 };\\n    let serialized = serde_json::to_string(&point).unwrap();\\n    println!(\\\"serialized = {}\\\", serialized);\\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\\n    println!(\\\"deserialized = {:?}\\\", deserialized);\\n}\\n\")), mdx(\"p\", null, \"Finally, we can run the package:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo run\\n\")), mdx(\"p\", null, \"You should see the following at the bottom of the output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"serialized = {\\\"x\\\":1,\\\"y\\\":2}\\ndeserialized = Point { x: 1, y: 2 }\\n\")), mdx(\"p\", null, \"Now with our baseline, we can try the REPLs and runners.\"), mdx(\"h2\", {\n    \"id\": \"evcxr-repl\"\n  }, \"Evcxr REPL\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/google/evcxr/blob/master/evcxr_repl/\"\n  }), \"Evcxr REPL\"), \" is a REPL for Rust that uses the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/google/evcxr/blob/master/evcxr/README.md\"\n  }), \"evcxr\"), \" execution context. For our purposes, we don\\u2019t need to go into depth how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"evcxr\"), \" works, let\\u2019s just get things setup and run.\"), mdx(\"h3\", {\n    \"id\": \"setup\"\n  }, \"Setup\"), mdx(\"p\", null, \"Before you install the REPL, you must download a local copy of Rust\\u2019s source code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ rustup component add rust-src\\n\")), mdx(\"p\", null, \"Now you can go ahead and install the binary:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo install evcxr_repl\\n\")), mdx(\"p\", null, \"Source: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/google/evcxr/blob/master/evcxr_repl/README.md#installation-and-usage\"\n  }), \"evcxr/README.md at master \\xB7 google/evcxr \\xB7 GitHub\")), mdx(\"h3\", {\n    \"id\": \"run\"\n  }, \"Run\"), mdx(\"p\", null, \"Enter the following lines in the REPL (without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \">> \"), \") to get the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"same\"), \" output as the Cargo package :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ evcxr\\n>> :dep serde = { version = \\\"1.0\\\", features = [\\\"derive\\\"] }\\n>> :dep serde_json = { version = \\\"1.0\\\" }\\n>> use serde::{Serialize, Deserialize};\\n>> #[derive(Serialize, Deserialize, Debug)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n>> let point = Point { x: 1, y: 2 };\\n>> let serialized = serde_json::to_string(&point).unwrap();\\n>> println!(\\\"serialized = {}\\\", serialized);\\n>> let deserialized: Point = serde_json::from_str(&serialized).unwrap();\\n>> println!(\\\"deserialized = {:?}\\\", deserialized);\\n\")), mdx(\"p\", null, \"A few things to note about the REPL session:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \":dep\"), \" lines are equivalent to the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[dependencies]\"), \" section of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Cargo.toml\"), \" in the Cargo package\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The session does not end until we exit the REPL. We can continue to work with the previous lines until we exit or the REPL is reset.\")), mdx(\"p\", null, \"It isn\\u2019t hard to imagine how this REPL session would be useful when exploring the functionality of an API or doing some one-off work. Remember to save you session (copy and paste) before closing out of the REPL, otherwise your work may be lost.\"), mdx(\"p\", null, \"Unfortunately, if you want to run previously written code in the REPL, you have to enter the code in one statement at a time. Running code in different sessions is where runners come into play.\"), mdx(\"h2\", {\n    \"id\": \"runner\"\n  }, \"runner\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/stevedonovan/runner\"\n  }), \"runner\"), \" compiles, links, and runs a Rust script (or snippet) without the boilerplate Cargo package. Let\\u2019s setup \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \" and run our example to see how it works with a script.\"), mdx(\"h3\", {\n    \"id\": \"setup-1\"\n  }, \"Setup\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo install runner\\n\")), mdx(\"h3\", {\n    \"id\": \"run-1\"\n  }, \"Run\"), mdx(\"p\", null, \"First we need to add the Serde dependencies to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \"\\u2019s static cache (just trust me). Run the following command to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"serde\"), \" and initialize the static cache:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ runner add serde\\n\")), mdx(\"p\", null, \"Now we will edit the static cache manually:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ runner edit\\n\")), mdx(\"p\", null, \"At the bottom of the file you will see:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"serde=\\\"*\\\"\\n\")), mdx(\"p\", null, \"Replace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"serde=\\u201C*\\u201D\"), \" with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"serde = { version = \\\"1.0\\\", features = [\\\"derive\\\"] }\\nserde_json = \\\"1.0\\\"\\n\")), mdx(\"p\", null, \"Save the file and now we will rebuild the static cache:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ runner --build\\n\")), mdx(\"p\", null, \"The dependencies are now available for our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \" script that we are now going to create. \"), mdx(\"p\", null, \"Copy the following contents to a new file named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner-serde-example.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"extern crate serde_json;\\nuse serde::{Serialize, Deserialize};\\n\\n#[derive(Serialize, Deserialize, Debug)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nlet point = Point { x: 1, y: 2 };\\nlet serialized = serde_json::to_string(&point).unwrap();\\nprintln!(\\\"serialized = {}\\\", serialized);\\nlet deserialized: Point = serde_json::from_str(&serialized).unwrap();\\nprintln!(\\\"deserialized = {:?}\\\", deserialized);\\n\")), mdx(\"p\", null, \"Finally, run the script:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ runner -s runner-serde-example.rs\\nserialized = {\\\"x\\\":1,\\\"y\\\":2}\\ndeserialized = Point { x: 1, y: 2 }\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-s\"), \"  in the command tells \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \" to \\u201Cevaluate expressions against crates compiled as static libraries.\\u201D This is necessary so we can use the Serde crates we added to the static cache earlier.\"), mdx(\"p\", null, \"In addition to running scripts, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \" also supports running expressions, similar to running one statement in a REPL.\\nHere is an example using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"serde_json\"), \" dependency we added earlier to deserialize an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Object\"), \" from a string of JSON text:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"$ runner -s -Xserde_json -e 'serde_json::from_str::<serde_json::Value>(r#\\\"{\\\"foo\\\":\\\"bar\\\"}\\\"#).unwrap()'\\nObject({\\\"foo\\\": String(\\\"bar\\\")})\\n\")), mdx(\"p\", null, \"Managing the dependencies with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \" can be somewhat cumbersome. Script dependencies are managed outside the script and only one version of crate can be added to the static cache at a time.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo-eval\"), \" is another runner that has a different solution to managing dependencies and similar features to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runner\"), \".\"), mdx(\"h2\", {\n    \"id\": \"cargo-eval\"\n  }, \"cargo-eval\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/reitermarkus/cargo-eval\"\n  }), \"cargo-eval\"), \" is a Cargo subcommand that enables you to run Rust scripts (or expressions). Let\\u2019s setup \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo-eval\"), \" and run our example to see how it works with a script.\"), mdx(\"h3\", {\n    \"id\": \"setup-2\"\n  }, \"Setup\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo install cargo-eval\\n\")), mdx(\"h3\", {\n    \"id\": \"run-2\"\n  }, \"Run\"), mdx(\"p\", null, \"Create a new file called  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo-eval-serde-example.rs\"), \" and copy in the following script contents:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"//! ```cargo\\n//! [dependencies]\\n//! serde = { version = \\\"1.0\\\", features = [\\\"derive\\\"] }\\n//! serde_json = \\\"1.0\\\"\\nuse serde::{Serialize, Deserialize};\\n\\n#[derive(Serialize, Deserialize, Debug)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nfn main() {\\n    let point = Point { x: 1, y: 2 };\\n    let serialized = serde_json::to_string(&point).unwrap();\\n    println!(\\\"serialized = {}\\\", serialized);\\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\\n    println!(\\\"deserialized = {:?}\\\", deserialized);\\n}\\n\")), mdx(\"p\", null, \"The first line of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo-eval-serde-example.rs\"), \" denotes the start of a partial Cargo manifest. In this section you can configure dependencies and manifest information. The rest of the script should look familiar at this point. We have all we need for our example, so let\\u2019s run the script.\"), mdx(\"p\", null, \"Run the script with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ cargo eval cargo-eval-serde-example\\n...\\nserialized = {\\\"x\\\":1,\\\"y\\\":2}\\ndeserialized = Point { x: 1, y: 2 }\\n\")), mdx(\"p\", null, \"In addition to running scripts, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo-eval\"), \" includes other features, such as running benchmarks and tests.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"We have now implemented the same example with a Cargo project, a REPL, and two runners.\\nHopefully you feel more comfortable with each tool and have some ideas of when you can use them to decrease your iteration speed and improve your workflow.\"), mdx(\"p\", null, \"We just touched on the capabilities these different tools. You should check out each tool to see the full list of features and options.\"), mdx(\"p\", null, \"For more examples implemented with these tools, check out \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ozbe/rust-repls-and-runners\"\n  }), \"GitHub - ozbe/rust-repls-and-runners: A collection of examples implemented with different Rust REPLs & Runners.\")), mdx(\"p\", null, \"If you have any questions on what was covered or have any thoughts or experiences with these tools, please share them in the comments!\"), mdx(\"h2\", {\n    \"id\": \"updates\"\n  }, \"Updates\"), mdx(\"h3\", {\n    \"id\": \"2020-02-13\"\n  }, \"2020-02-13\"), mdx(\"p\", null, \"A few more runners and REPLs:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/fanzeyi/cargo-play\"\n  }), \"fanzeyi/cargo-play\"), \" - A local Rust playground\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/fornwall/rust-script\"\n  }), \"fornwall/rust-script\"), \" - Run Rust files and expressions as scripts without any setup or compilation step.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/murarth/rusti\"\n  }), \"murarth/rusti\"), \" - (Deprecated) REPL for the Rust programming language\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/kurtlawrence/papyrus\"\n  }), \"kurtlawrence/papyrus\"), \" - (Deprecated) Rust REPL\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/the-three-rs-rust-repl-runner/","title":"The Three \"R\"s: Rust, REPL, Runner","tags":[],"date":"January 21, 2021","image":null,"imageAlt":null,"imageCaptionText":null,"imageCaptionLink":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"971233dd-f8c5-53fd-8985-dff7c761d0f1","excerpt":"Gather and share feedback from your direct reportâ€™s peers. Celebrate with them what others see as their accomplishments and work together toâ€¦","slug":"/request-peer-feedback/","title":"Request Peer Feedback","date":"January 18, 2021"},"next":null},"pageContext":{"id":"cefc5047-87a1-5b41-811a-a327c6aad5b0","previousId":"971233dd-f8c5-53fd-8985-dff7c761d0f1","maxWidth":1380}},"staticQueryHashes":["2744905544","3090755652","386998304","764694655"]}